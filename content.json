{"meta":{"title":"Sheng1024","subtitle":null,"description":"Sheng1024 的个人博客，学习笔记","author":"Sheng1024","url":"https://sheng1024.github.io","root":"/"},"pages":[{"title":"404","text":"","path":"404/index.html","date":"09-23","excerpt":""},{"title":"关于","text":"Sheng1024 - Github","path":"about/index.html","date":"09-23","excerpt":""},{"title":"search","text":"","path":"search/index.html","date":"09-23","excerpt":""}],"posts":[{"title":"《ECMAScript 6 入门》笔记","text":"[TOC] 1.ECMAScript 6 简介1.ECMAScript 和 JavaScript 的关系前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 JScript 和 ActionScript） 2.ES6 与 ECMAScript 2015 的关系3.语法提案的批准流程4.ECMAScript 的历史5.部署进度https://kangax.github.io/compat-table/es6/ 6.Babel 转码器7.Traceur 转码器2.let 和 const 命令1.let 命令 基本用法 所声明的变量，只在let命令所在的代码块内有效 不存在变量提升 暂时性死区 不允许重复声明2.块级作用域3.const 命令 基本用法 const声明一个只读的常量，一旦声明，常量的值就不能改变 本质 变量指向的那个内存地址所保存的数据不得改动 ES6 声明变量的六种方法 var function let const import class4.顶层对象的属性5.globalThis 对象3.变量的解构赋值1.数组的解构赋值2.对象的解构赋值3.字符串的解构赋值4.数值和布尔值的解构赋值5.函数参数的解构赋值6.圆括号问题7.用途4.字符串的扩展1.字符串的 Unicode 表示法2.字符串的遍历器接口3.直接输入 U+2028 和 U+20294.JSON.stringify() 的改造5.模板字符串模板字符串 ( template string ) 是增强版的字符串，用反引号 ( ` ) 标识模板字符串中嵌入变量，需要将变量名写在 ${} 之中6.实例:模板编译7.标签模板模板字符串紧跟在一个函数名后面8.模板字符串的限制5.字符串的新增方法1.String.fromCodePoint()2.String.raw()3.实例方法: codePonitAt()4.实例方法: normalize()5.实例方法: includes(), startsWith(), endsWith()6.实例方法: repeat()7.实例方法: padStart(), padEnd()8.实例方法: trimStart(), trimEnd()9.实例方法: matchAll()6.正则的扩展1.RegExp 构造函数2.字符串的正则方法3.u 修饰符4.RegExp.prototype.unicode 属性5.y 修饰符6.RegExp.prototype.sticky 属性7.RegExp.prototype.flags 属性8.s 修饰符:dotAll 模式9.后行断言10.Unicode 属性类11.具名组匹配12.String.prototype.matchAll7.数值的扩展1.二进制和八进制表示法2.Number.isFinite(), Number.isNaN()3.Number.parseInt(), Number.parseFloat()4.Number.isInteger()5.Number.EPSILON一个极小的常量，表示1与大于1的最小浮点数之间的差 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// \"0.00000000000000022204\" Number.EPSILON实际上是 JavaScript 能够表示的最小精度 6.安全整数和 Number.isSafeInteger()123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 7.Math 对象的扩展 Math.trunc() Math.sign() Math.cbrt() Math.clz32() Math.imul() Math.fround() Math.hypot() 对数方法 Math.expm1() Math.log1p() Math.log10() Math.log2() 双曲函数方法 Math.sinh(x) Math.cosh(x) Math.tanh(x) Math.asinh(x) Math.acosh(x) Math.atanh(x)8.指数运算符** 右结合123// 相当于 2 ** (3 ** 2)2 ** 3 ** 2// 512 8.函数的扩展1.函数参数的默认值参数变量时默认声明的，在函数体中，不能用let或const再次声明，否则会报错。使用参数默认值时，函数不能有同名参数。应用：指定某一个参数不得省略 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 2.rest 参数ES6引入 rest 参数(形式为...变量名)， 用于获取函数的多余参数，这样就不需要使用arguments对象了 3.严格模式只要函数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式地设定为严格模式，否则会报错 4. name 属性5.箭头函数 基本用法 =&gt; 使用注意点 函数体内的this对象，就是定义时所在的对象,而不是使用时所在的对象 不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误 不可以使用arguments对象，该对象在函数体内不存在，如果要用，可以用 rest 参数代替 不可以使用yield命令，因此箭头函数不能用作Generator函数 由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向 6.尾调用优化7.函数参数的尾逗号8.Function.prototypr.toString()9.catch 命令的参数省略9.数组的扩展1.扩展运算符 含义 扩展运算符 ( spread ) 是三个点 ( ... )， 它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列 该运算符主要用于函数调用 替代函数的 apply 方法 扩展运算符的应用 (1) 复制数组 (浅拷贝) (2) 合并数组 (浅拷贝) (3) 与结构赋值结合 (4) 字符串 (5) 实现了 Iterator 接口的对象 (6) Map 和 Set 结构，Generator 函数2.Array.from()Array.from方法用于将两类对象转为真正的数组:类似数组的对象 ( array-like object ) 和可遍历 ( iterable ) 的对象 ( 包括 ES6 新增的数据结构 Set 和 Map )3.Array.of()4.数组实例的 copyWithin()5.数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员，它的参数是一个回调函数，所有数组成员依次执行该回调函数,直到找出第一个返回值为true的成员，然后返回该成员，如果没有符合条件的成员,则返回undefined6.数组实例的 fill()7.数组实例的 entries(), keys() 和 values()8.数组实例的 includes()9.数组实例的 flat(), flatMap()10.数组的空位10.对象的扩展1.属性的见解表示法2.属性名表达式3.方法的 name 属性4.属性的可枚举性和遍历5.super 关键字6.对象的扩展运算符11.对象的新增方法1. Object.is()Object.is是部署 “Same-value equality” (同值相等) 算法的方法，用来比较两个值是否严格相等 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true 2.Object.asign() 基本用法 Object.asign方法用于对象的合并，将源对象( source ) 的所有可枚举属性，复制到目标对象 ( target ) Object.asign方法的第一个参数是目标对象，后面的参数都是源对象 注意点 (1) 浅拷贝 Object.asign方法实行的是浅拷贝，而不是深拷贝 (2) 同名属性的替换 (3) 数组的处理 Object.asign可以用来处理数组，但是会把数组视为对象 (4) 取值函数的处理 Object.asign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制 1234567const source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 常见用途 (1) 为对象添加属性 (2) 为对象添加方法 (3) 克隆对象 (4) 合并多个对象 (5) 为属性指定默认值3.Object.getOwnPropertyDescriptors()ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象的所有自身属性(非继承属性)的描述对象4.proto属性，Object.setPrototypeOf()， Object.getPrototypeOf() Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身 Object.getPrototypeOf方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象 5.Object.keys(), Object.values(), Object.entries() Object.keys方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键名 Object.values方法返回一个数组，成员是参数对象自身的(不含继承的)所有可遍历(enumerable)属性的键值 Object.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组 6.Object.fromEntries()Object.fromEntries方法是Object.entries的逆操作，用于将一个键值对数组转为对象 12.Symbol1.概述Symbol表示独一无二的值，是一种类似于字符串的数据类型 1234let s = Symbol();typeof s// \"symbol\" Symbol 值不能与其他类型的值进行运算，会报错；但是可以显示转为字符串，也可以转为布尔值，不能转为数值 1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 12345678910let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123; // ...&#125;Number(sym) // TypeErrorsym + 2 // TypeError 2.Symbol.prototype.ES2019 提供了一个实例属性description，直接返回Symbol的描述 123const sym = Symbol('foo');sym.description // \"foo\" 3.作为属性名的Symbol注意: Symbol 值作为对象属性名时，不能用点运算符 4.实例：消除魔术字符串魔术字符串指的是，在一个代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数值 12345678910111213const shapeType = &#123; triangle: Symbol()&#125;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 5.属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值 6.Symbol.for(), Symbol.keyFor()Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。Symbol.keyFor方法返回一个已登记的 Symbol 类型的key 12345let s1 = Symbol.for(\"foo\");Symbol.keyFor(s1) // \"foo\"let s2 = Symbol(\"foo\");Symbol.keyFor(s2) // undefined 7.实例：模块的 Singleton 模式Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。 8.内置的 Symbol 值 Symbol.hasInstance 对象的该属性，指向一个内部方法，当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法 Symbol.isConcatSpreadable 对象的该属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开 Symbol.species 对象的该属性，指向一个构造函数，创建衍生对象时，会使用该属性。 1234567891011class T1 extends Promise &#123;&#125;class T2 extends Promise &#123; static get [Symbol.species]() &#123; return Promise; &#125;&#125;new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // truenew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false Symbol.match 对象的该属性，指向一个函数，当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值 Symbol.replace 对象的该属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值 Symbol.search Symbol.split Symbol.iterator Symbol.toPrimitive Symbol.toStringTag Symbol.unscopables 13.Set 和 Map 数据结构1.Set 基本用法 数据结构Set类似于数组，但是成员的值都是唯一的 向 Set 加入值的时候，不会发生类型转换 Set 实例属性 Set.prototype.constructor Set.prototype.size Set 实例操作方法 Set.prototype.add(value) Set.prototype.delete(value) Set.prototype.has(value) Set.prototype.clear() Set 实例遍历方法 Set结构的遍历顺序就是插入顺序 Set.prototype.keys() Set.prototype.values() Set.prototype.entries() Set.prototype.forEach() 应用1234567891011121314let a = new Set([1, 2, 3]);let b = new Set([4, 3, 2]); // 并集let union = new Set([...a, ...b]);// Set &#123;1, 2, 3, 4&#125; // 交集let intersect = new Set([...a].filter(x =&gt; b.has(x)));// set &#123;2, 3&#125; // 差集let difference = new Set([...a].filter(x =&gt; !b.has(x)));// Set &#123;1&#125; 2.WeakSet WeakSet 的成员只能是对象，而不能是其他类型的值 WeakSet 中的对象都是弱引用，即垃圾回收机制不考虑 WeakSet 对该对象的引用3.Map 注意 只有对同一个对象的引用，Map结构才将其视为同一个键 1234const map = new Map();map.set(['a'], 555);map.get(['a']) // undefined （1）size属性 （2）Map.prototype.set(key,value) （3）Map.prototype.get(key) （4）Map.prototype.has(key) （5）Map.prototype.delete(key) （6）Map.prototype.clear()遍历方法 Map.prototype.keys() Map.prototype.values() Map.prototype.entries() Map.prototype.forEach()与其他数据结构的转换 （1）Map 转为数组 （2）数组转为 Map （3）Map 转为对象 （4）对象转为 Map （5）Map 转为 JSON （6）JSON 转为 Map4.WeakMap WeakMap只接受对象作为键名（null除外） WeakMap的键名所指向的对象，不计入垃圾回收机制 应用 DOM节点作为键名14.Proxy1.概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming） Proxy 实际上重载了（overload）了点运算符，即用自己的定义覆盖了语言的原始定义 var proxy = new Proxy(target, handler) new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为 注意 要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象进行操作 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用var object = { proxy: new Proxy(target, handler) } Proxy 支持的拦截操作,一共13种 get(target,propKey,receiver) set(target,propKey,value,receiver) has(target,propKey) deleteProperty(target,propKey) ownKeys(target) getOwnPropertyDescriptor(target,propkey) defineProperty(target,propKey,propDesc) preventExtensions(target) getPrototypeOf(target) isExtensible(target) setPrototypeOf(target,proto) apply(target,ctx,args) construct(target,args) 2.Proxy 实例的方法如果一个属性不可配置（configurable）且不可写（writable）,则 Proxy 不能修改该属性，否则通过 Proxy 对象访问该属性会报错 123456789101112131415161718const target = Object.defineProperties(&#123;&#125;, &#123; foo: &#123; value: 123, writable: false, configurable: false &#125;,&#125;);const handler = &#123; get(target, propKey) &#123; return 'abc'; &#125;&#125;;const proxy = new Proxy(target, handler);proxy.foo// TypeError: Invariant check failed 3.Proxy.revocable()Proxy.revcoable方法返回一个可取消的 Proxy 实例 12345678910let target = &#123;&#125;;let handler = &#123;&#125;;let &#123;proxy, revoke&#125; = Proxy.revocable(target, handler);proxy.foo = 123;proxy.foo // 123revoke();proxy.foo // TypeError: Revoked 4.this 问题在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理 1234567891011const target = &#123; m: function () &#123; console.log(this === proxy); &#125;&#125;;const handler = &#123;&#125;;const proxy = new Proxy(target, handler);target.m() // falseproxy.m() // true 5.实例：Web 服务的客户端15.Reflect1.概述 （1）将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上 （2）修改某些Object方法的返回结果，让其变得合理 （3）让Object操作都变成函数行为 （4）Reflect对象的方法与Proxy对象的方法一一对应2.静态方法Reflect对象一共有13个静态方法 Reflect.apply(target, thisArg, args) Reflect.construct(target, args) Reflect.get(target, name, receiver) Reflect.set(target, name, value, receiver) Reflect.defineProperty(target, name, desc) Reflect.deleteProperty(target, name) Reflect.has(target, name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 3.实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数会自动执行 123456789101112131415161718192021222324const queuedObservers = new Set();const observe = fn =&gt; queuedObservers.add(fn);const observable = obj =&gt; new Proxy(obj, &#123;set&#125;);function set(target, key, value, receiver) &#123; const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result;&#125;const person = observable(&#123; name: '张三', age: 20&#125;);function print() &#123; console.log(`$&#123;person.name&#125;, $&#123;person.age&#125;`)&#125;observe(print);person.name = '李四';// 输出// 李四, 20 16.Promise 对象1.Promise 的含义2.基本用法3.Promise.prototype.then()4.Promise.prototype.catch()5.Promise.prototype.finally()6.Promise.all()7.Promise.race()8.Promise.resolve()9.Promise.reject()10.应用11.Promise.try()17.Iterator 和 for…of 循环1.Iterator(遍历器)的概念作用 为各种数据结构，提供一个统一分、简便的访问接口 使得数据结构的成员能够按某种次序排列 供for...of消费 2.默认 Iterator 接口原生具备 Iterator 接口的数据结构如下 Array Map Set String TypedArray 函数的 Arguments 对象 NodeList 对象 下面是通过遍历器实现指针结构的例子 1234567891011121314151617181920212223242526272829303132function Obj(value) &#123; this.value = value; this.next = null;&#125;Obj.prototype[Symbol.iterator] = function() &#123; var iterator = &#123; next: next &#125;; var current = this; function next() &#123; if (current) &#123; var value = current.value; current = current.next; return &#123; done: false, value: value &#125;; &#125; else &#123; return &#123; done: true &#125;; &#125; &#125; return iterator;&#125;var one = new Obj(1);var two = new Obj(2);var three = new Obj(3);one.next = two;two.next = three;for (var i of one)&#123; console.log(i); // 1, 2, 3&#125; 3.调用 Iterator 接口的场合 解构赋值 扩展运算符 yield* 其他场合 任何接受数组作为参数的场合可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的 4.字符串的 Iterator 接口5.Iterator 接口与 Generator 函数6.遍历器对象的 return(), throw()return()方法的使用场合是，如果for...of循环提前退出，就会调用return方法注意 return方法必须返回一个对象 7.for…of 循环遍历所有数据结构的统一方法 遍历数组 12345678910let arr = [3, 5, 7];arr.foo = 'hello';for (let i in arr) &#123; console.log(i); // \"0\", \"1\", \"2\", \"foo\"&#125;for (let i of arr) &#123; console.log(i); // \"3\", \"5\", \"7\"&#125; 无法使用break或return命令中途跳出forEach循环 18.Generator 函数的语法1.简介Generator 函数是一个状态机，封装了多个内部状态Generator 函数会返回一个遍历器对象，是一个遍历器对象生成函数特征: function关键字与函数名之间有一个星号 函数体内部使用yield表达式调用 Generator 函数，返回一个遍历器对象，代表 Generator 函数的内部指针。以后每次调用遍历器对象的next方法，就返回一个有着value和done两个属性的对象 123456789101112131415161718function* helloWorldGenerator() &#123; yield 'hello'; yield 'world'; return 'ending';&#125;var hw = helloWorldGenerator();hw.next()// &#123; value: 'hello', done: false &#125;hw.next()// &#123; value: 'world', done: false &#125;hw.next()// &#123; value: 'ending', done: true &#125;hw.next()// &#123; value: undefined, done: true &#125; 2.next 方法的参数yield表达式本身没有返回值，或者说总是返回undefineed，next方法恩罗带一个参数，该参数就会被当做上一个yield表达式的返回值 123456789101112131415function* foo(x) &#123; var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z);&#125;var a = foo(5);a.next() // Object&#123;value:6, done:false&#125;a.next() // Object&#123;value:NaN, done:false&#125;a.next() // Object&#123;value:NaN, done:true&#125;var b = foo(5);b.next() // &#123; value:6, done:false &#125;b.next(12) // &#123; value:8, done:false &#125;b.next(13) // &#123; value:42, done:true &#125; 3.for…of 循环for...of循环可以自动遍历 Generator 函数运行时生成的Iterator对象，且此时不再需要调用nest方法 4.Generator.prototype.throw()Generator 函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在 Generator 函数体内捕获 throw方法抛出的错误要被内部捕获，前提示必须至少执行过一次next方法 5.Generator.prototype.return()Generator 函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历 Generator 函数 如果 Generator 函数内部有try...finally代码块，且正在执行try代码块，那么return方法会推迟到finally代码块执行完再执行 6.next()、throw()、return() 的共同点作用 让 Generator 函数恢复执行，并且使用不同的语句替换yield表达式 7.yield* 表达式用来在一个 Generator 函数里面执行另一个 Generator 函数 1234567891011121314151617181920212223242526272829303132333435// 下面是二叉树的构造函数，// 三个参数分别是左树、当前节点和右树function Tree(left, label, right) &#123; this.left = left; this.label = label; this.right = right;&#125;// 下面是中序（inorder）遍历函数。// 由于返回的是一个遍历器，所以要用generator函数。// 函数体内采用递归算法，所以左树和右树要用yield*遍历function* inorder(t) &#123; if (t) &#123; yield* inorder(t.left); yield t.label; yield* inorder(t.right); &#125;&#125;// 下面生成二叉树function make(array) &#123; // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2]));&#125;let tree = make([[['a'], 'b', ['c']], 'd', [['e'], 'f', ['g']]]);// 遍历二叉树var result = [];for (let node of inorder(tree)) &#123; result.push(node);&#125;result// ['a', 'b', 'c', 'd', 'e', 'f', 'g'] 8.作为对象属性的 Generator 函数12345let obj = &#123; * myGeneratorMethod() &#123; ··· &#125;&#125;; 9.Generator 函数的 thisGenerator 函数总是返回一个遍历器，ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Generator 函数的prototype对象上的方法 12345678910111213141516171819function* gen() &#123; this.a = 1; yield this.b = 2; yield this.c = 3;&#125;function F() &#123; return gen.call(gen.prototype);&#125;var f = new F();f.next(); // Object &#123;value: 2, done: false&#125;f.next(); // Object &#123;value: 3, done: false&#125;f.next(); // Object &#123;value: undefined, done: true&#125;f.a // 1f.b // 2f.c // 3 10.含义Generator 是实现状态机的最佳机构 12345678var clock = function* () &#123; while (true) &#123; console.log('Tick!'); yield; console.log('Tock!'); yield; &#125;&#125;; 11.应用 异步操作的同步化表达 控制流管理 部署 Iterator 接口 作为数据结构 19.Generator 函数的异步应用1.传统方法 回调函数 事件监听 发布/订阅 Promise 对象 2.基本概念异步 一个任务不是连续完成的 回调函数 把任务的第二段单独写在一个函数里，等到重新执行这个任务的时候，就直接调用这个函数 Promise 解决”回调函数地狱”（callback hell） 3.Generator 函数协程 多个线程互相协作，完成异步任务 协程的 Generator 函数实现 最大特点就是可以交出函数的执行权 Generator函数的数据交换和错误处理 4.Thunk 函数参数的求值策略 传值调用（call by value）C、JavaScript 传名调用（call by name）Haskell 含义 编译器的“传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体，这个临时函数就叫做 Thunk 函数 在 JavaScript 语言中，Thunk 函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数 Thunk 函数转换 12345678910111213141516171819// ES5版本var Thunk = function(fn)&#123; return function ()&#123; var args = Array.prototype.slice.call(arguments); return function (callback)&#123; args.push(callback); return fn.apply(this, args); &#125; &#125;;&#125;;// ES6版本const Thunk = function(fn) &#123; return function (...args) &#123; return function (callback) &#123; return fn.call(this, ...args, callback); &#125; &#125;;&#125;; Thunkify 模块 使用 1234567var thunkify = require('thunkify');var fs = require('fs');var read = thunkify(fs.readFile);read('package.json')(function(err, str)&#123; // ...&#125;); Thunk 自动执行 Generator 函数 1234567891011121314151617181920function run(fn) &#123; var gen = fn(); function next(err, data) &#123; var result = gen.next(data); if (result.done) return; result.value(next); &#125; next();&#125;var g = function* ()&#123; var f1 = yield readFileThunk('fileA'); var f2 = yield readFileThunk('fileB'); // ... var fn = yield readFileThunk('fileN');&#125;;run(g); 5. co 模块前提 Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象 Stream 模式使用 EventEmitter API 会释放三个事件 data事件：下一块数据块已经准备好了 end事件：整个“数据流”处理完了 error事件：发生错误 20.async 函数1.含义Generator 函数的语法糖 async函数将 Generator 函数的星号（*）替换成async，将yield替换成await 改进 内置执行器 更好的语义 更广的适用性 返回值是 Promise 进一步说，async函数完全可以看做多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖 2.基本用法3.语法4. async 函数的实现原理5.与其他异步处理方法的比较6.实例: 按顺序完成异步操作7.顶层 await21.Class 的基本语法1.简介ES6 的类，完全可以看做构造函数的另一种写法 123456class Point &#123; // ...&#125;typeof Point // \"function\"Point === Point.prototype.constructor // true 类的内部所有定义的方法，都是不可枚举的（non-enumerable） 类必须使用new调用，否则会报错，普通构造函数不用new也可以执行 在“类”的内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为 存值函数和取值函数是设置在属性的 Descriptor 对象上的 1234567891011121314151617181920class CustomHTMLElement &#123; constructor(element) &#123; this.element = element; &#125; get html() &#123; return this.element.innerHTML; &#125; set html(value) &#123; this.element.innerHTML = value; &#125;&#125;var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, \"html\");\"get\" in descriptor // true\"set\" in descriptor // true 类的属性名，可以采用表达式 注意点 严格模式 默认就是严格模式 不存在提升（hoist） 12345&#123; let Foo = class &#123;&#125;; class Bar extends Foo &#123; &#125;&#125; name 属性 name属性总是返回紧跟在class关键字后面的类名 Generator 方法 方法前面加上星号（*） 12345678910111213141516class Foo &#123; constructor(...args) &#123; this.args = args; &#125; * [Symbol.iterator]() &#123; for (let arg of this.args) &#123; yield arg; &#125; &#125;&#125;for (let x of new Foo('hello', 'world')) &#123; console.log(x);&#125;// hello// world this 的指向 默认指向类的实例，但2必须非常小心，一旦单独使用该方法，很可能报错 2.静态方法如果在一个方法前，加上static关键字，表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法” 注意 如果静态方法中包含this关键字，这个this指的是类，而不是实例 静态方法可以与非静态方法重名 父类的静态方法，可以被子类继承 3.实例属性的新写法实例属性除了定义在constructor()方法里面的this上面，也可以定义在类的最顶层 4.静态属性12345678910// 老写法class Foo &#123; // ...&#125;Foo.prop = 1;// 新写法class Foo &#123; static prop = 1;&#125; 5.私有方法和私有属性解决方案 命名前加下划线 将私有方法移出模块 1234567891011class Widget &#123; foo (baz) &#123; bar.call(this, baz); &#125; // ...&#125;function bar(baz) &#123; return this.snaf = baz;&#125; 将私有方法的名字命名为一个Symbol值 提案 属性名、方法名前加# 6. new.target 属性该属性一般用在构造函数之中，返回new命令作用于的那个构造函数 如果构造函数不是通过new命令或Reflect.construct()调用的，new.target会返回undefined 12345678910111213141516171819function Person(name) &#123; if (new.target !== undefined) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;// 另一种写法function Person(name) &#123; if (new.target === Person) &#123; this.name = name; &#125; else &#123; throw new Error('必须使用 new 命令生成实例'); &#125;&#125;var person = new Person('张三'); // 正确var notAPerson = Person.call(person, '张三'); // 报错 22.Class 的继承1.简介Class 可以通过extends关键字实现继承 子类必须在constructor方法中调用super方法，否则新建实例会报错 这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。 如果不调用super方法，子类就得不到this对象。 只有调用super之后，才能使用this关键字 2.Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类 3. super 关键字 作为函数是，super()只能用在子类的构造函数之中，用在其他地方就会报错 super作为对象时，在普通方法中，指向父类的原型对象；在静态方法中，指向父类 4.类的 prototype 属性和 proto 属性5.原生构造函数的继承ES5 是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数 ES6 允许继承原生构造函数定义子类，因为 ES6 是先新建父类的实例对象this，然后再用子类的构造函数修饰this,使得父类的所有行为都可以继承 6.Mixin 模式的实现Mixin 指的是多个对象合成一个新的对象，新对象各个组成成员的接口 1234567891011121314151617181920212223242526272829303132function mix(...mixins) &#123; class Mix &#123; constructor() &#123; for (let mixin of mixins) &#123; copyProperties(this, new mixin()); // 拷贝实例属性 &#125; &#125; &#125; for (let mixin of mixins) &#123; copyProperties(Mix, mixin); // 拷贝静态属性 copyProperties(Mix.prototype, mixin.prototype); // 拷贝原型属性 &#125; return Mix;&#125;function copyProperties(target, source) &#123; for (let key of Reflect.ownKeys(source)) &#123; if ( key !== 'constructor' &amp;&amp; key !== 'prototype' &amp;&amp; key !== 'name' ) &#123; let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); &#125; &#125;&#125;class DistributedEdit extends mix(Loggable, Serializable) &#123; // ...&#125; 23.Module 的语法1.概述12// CommonJS模块let &#123; stat, exists, readFile &#125; = require('fs'); 整体加载fs模块（加载所有方法），“运行时加载” 12// ES6模块import &#123; stat, exists, readFile &#125; from 'fs'; 从fs模块加载3个方法，其他方法不加载，“编译时加载”，“静态加载” 2.严格模式ES6 的模块自动采用严格模式 注意 ES6 模块之中，顶层的this指向undefined,即不应该在顶层代码使用this 3. export 命令 注意 export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名 4. import 命令import命令输入的变量都是只读的，可以使用as关键字重命名 注意 import命令具有提升效果 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次 5.模块的整体加载1import * as circle from './circle'; 6. export default 命令本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句 7. export 与 import 的复合写法12345// 接口改名export &#123; foo as myFoo &#125; from 'my_module';// 整体输出export * from 'my_module'; 8.模块的继承9.跨模块常量10. import()import()动态加载，类似于 Node 的require方法 import()异步加载，require同步加载 import()返回一个 Promise 对象 适用场合 按需加载 条件加载 动态的模块路径 注意 import()加载模块成功以后，这个模块会作为一个对象，当做then方法的参数 24.Module 的加载实现1.浏览器加载 传统方法 &lt;script&gt; defer async 加载规则 type=&quot;module&quot;，异步加载 2.ES6模块与 CommentJS 模块的差异 CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 3.Node 加载Node 要求 ES6 模块采用.mjs后缀文件名 Node 规定 ES6 模块之中不能使用 CommonJS 模块的特有的一些内部变量 this arguments module exports __filename __dirname 4.循环加载 CommonJS 模块的循环加载 只输出已经执行的部分，还未执行的部分不会输出 ES6 模块的循环加载 5.ES6 模块的转码ES6 module transplier SystemJS 25.编程风格1.块级作用域 let 取代 var 全局常量和线程安全 2.字符串 静态字符串一律使用单引号或反引号，不使用双引号 动态字符串使用反引号 3.解构赋值 使用数组成员对变量赋值时，优先使用解构赋值 函数的参数如果是对象的成员，优先使用解构赋值 如果函数返回多个值，优先使用对象的解构赋值 4.对象 单行定义的对象，最后一个成员不以逗号结尾 多行定义的对象，最后一个成员以逗号结尾 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法 如果对象的属性名时动态的，可以在创造对象的时候，使用属性表达式定义 对象的属性和方法，尽量采用简洁表达式法 5.数组 使用扩展运算符（…）拷贝数组 使用 Array.from 方法，将类似数组的对象转为数组 6.函数 立即执行函数可以写成箭头函数的形式 使用匿名函数当作参数的场合，尽量使用箭头函数代替 箭头函数取代Function.prototype.bind，不应该再用 self/_this/that 绑定 this 简单的、单行的、不会复用的函数，建议采用箭头函数 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数 1234567// badfunction divide(a, b, option = false ) &#123;&#125;// goodfunction divide(a, b, &#123; option = false &#125; = &#123;&#125;) &#123;&#125; 不要在函数体内使用 arguments 变量，使用 rest 运算符（…）代替 使用默认值语法设置函数参数的默认值 7.Map 结构只有模拟现实世界的实体对象时，才使用 Object 。如果只是需要 key:value的数据结构，使用 Map 结构 8.Class 总是使用 Class 取代需要 prototype 的操作 使用 extends实现继承 9.模块 使用import取代require 使用export取代module.exports 如果模块只有一个输出值，就使用export default，export default与export不要同时使用 不要在模块输入中使用通配符 如果模块默认输出一个函数，函数名的首字母应该小写 如果模块默认输出一个对象，对象名的首字母应该大写 10.ESLint 的使用GitHub - airbnb/javascript: JavaScript Style Guide 26.读懂规格1.概述ECMAScript 6 2.术语3.抽象操作的标准流程4.相等运算符5.数组的空位6.数组的 map 方法27.异步遍历器1.同步遍历器的问题2.异步遍历的接口3.for await…of4.异步 Generator 函数5.yield* 语句28.ArrayBuffer1.ArrayBuffer 对象2.TypedArray 视图3.复合视图4.DataView 视图5.二进制数组的应用6.SharedArrayBuffer7.Atomics 对象29.最新提案1. do 表达式2. throw 表达式3.链判断运算符4.Null 判断运算符5.函数的部分执行6.管道运算符7.数值分隔符8.BigInt 数据类型9.Math.signbit()10.双冒号运算符11.Realm API12.#!命令13. import.meta30.Decorator1.类的装饰2.方法的装饰3.为什么装饰不能用于函数?4. core-decorator.js5.使用装饰器自动发布事件6.Mixin7.Trait","path":"2019/09/23/《ECMAScript 6 入门》 笔记 /","date":"09-23","excerpt":"","tags":[{"name":"ES6","slug":"ES6","permalink":"https://sheng1024.github.io/tags/ES6/"},{"name":"ECMAScript 6","slug":"ECMAScript-6","permalink":"https://sheng1024.github.io/tags/ECMAScript-6/"},{"name":"阮一峰","slug":"阮一峰","permalink":"https://sheng1024.github.io/tags/阮一峰/"}]},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","path":"2019/09/17/hello-world/","date":"09-17","excerpt":"","tags":[]},{"title":"Git笔记","text":"常用指令 命令 注解 ssh-keygen -t rsa -C “邮箱地址” 生成SSH证书 cat ~/.ssh/id_rsa.pub 查看SSH证书 gitk 启动图形化界面 git remote add 远程仓库名 远程仓库地址 添加远程仓库地址 git remote rm 远程仓库名 删除远程仓库 git remote set-url 远程仓库名 远程仓库地址 修改远程仓库地址 git checkout 文件名 还原文件到上一个版本 bash常见命令1234567891011121314pwd (Print Working Directory) 查看当前目录cd (Change Directory) 切换目录ls (List)查看当前目录下的内容mkdir (Make Directory)创建目录touch 创建文件,如 touch index.htmlcat 查看全部文件内容,如 cat index.htmlrm (remove) 删除文件,删除空文件夹,如 rm index.html , rm Blogrm -rf 强制删除文件夹,非空文件夹也可以删除rmdir (Remove Directory) 删除文件夹,只能删除空文件夹mv (move) 移动文件或重命名,如 mv index.html ./demo/index.htmlcp (copy) 复制文件,如 cp index.html ./demo/index.htmlhead 查看文件前几行,如 head -5 index.htmlhistory 查看操作历史whoami 查看当前用户 资料文件 如何优雅地使用 Git - 掘金 优雅的提交你的 Git Commit Message - 掘金 如何使用 GitHub？ - 知乎 Git飞行规则 - GitHub Git的奇技淫巧 - Github 猴子都能懂的GIT入门 - 贝格乐（Backlog） 10 分钟学会Linux常用 bash命令 - Savorboard - 博客园Git Gui Sourcetree TortoiseGit参考文献 史上最浅显易懂的Git教程 - 廖雪峰的官方网站 Pro Git v2 - Scott Chacon 玩转Git三剑客 - 极客时间","path":"2019/09/17/git 笔记/","date":"09-17","excerpt":"","tags":[{"name":"git","slug":"git","permalink":"https://sheng1024.github.io/tags/git/"},{"name":"bash","slug":"bash","permalink":"https://sheng1024.github.io/tags/bash/"}]}]}